/**
 * Doctrine Spec:
 * - Barton ID: 99.99.99.07.08089.421
 * - Altitude: 10000 (Execution Layer)
 * - Input: data query parameters and filters
 * - Output: database records and metadata
 * - MCP: Composio (Neon integrated)
 */
/**
 * Step 2A People Validator API - Barton Doctrine Pipeline
 * Input: People Master File JSON (from Mapping App / Apify)
 * Output: JSON { rows_validated, rows_failed, details[] }
 *
 * For each record:
 * 1. Generate Barton unique_id
 * 2. Attach company_unique_id (parent)
 * 3. Lookup company_slot_unique_id based on slot_type
 * 4. Normalize phones → E.164
 * 5. Validate required fields: first_name, last_name, email OR phone
 * 6. Write valid rows → people_raw_intake
 * 7. Write audit entry → people_audit_log
 *
 * Uses Standard Composio MCP Pattern for ALL database operations
 */

import { StandardComposioNeonBridge } from '../utils/standard-composio-neon-bridge';

// ==============================================================================
// BARTON DOCTRINE: Tool Code Mapping
// ==============================================================================

const TOOL_CODES = {
  neon: '04',      // Direct Neon inserts
  apify: '07',     // Apify scraping (most common for people)
  dbeaver: '08'    // DBeaver CSV bulk import
} as const;

type ToolCode = keyof typeof TOOL_CODES;

// ==============================================================================
// TYPESCRIPT INTERFACES
// ==============================================================================

/**
 * People Master File JSON Structure (Input)
 * This comes from Apify Scraper, Apollo, or staging CSV
 * NOTE: Does NOT contain unique_id - that's generated by validator
 */
interface PersonMasterRecord {
  // REQUIRED: Company linkage
  company_unique_id: string;  // Parent company Barton ID
  slot_type: 'CEO' | 'CFO' | 'HR' | 'CTO' | 'CMO' | 'COO' | 'VP_SALES' | 'VP_MARKETING' | 'DIRECTOR' | 'MANAGER';

  // REQUIRED: Person identification
  first_name: string;
  last_name: string;

  // JOB DETAILS
  title?: string;
  seniority?: 'C-Level' | 'VP-Level' | 'Director-Level' | 'Manager-Level' | 'Individual Contributor' | 'Entry-Level';
  department?: string;

  // CONTACT INFO
  email?: string;
  work_phone_e164?: string;
  personal_phone_e164?: string;

  // SOCIAL PROFILES
  linkedin_url?: string;
  twitter_url?: string;
  facebook_url?: string;

  // ADDITIONAL DATA
  bio?: string;
  skills?: string;
  education?: string;
  certifications?: string;

  // SOURCE TRACKING
  source_system?: string;
  source_record_id?: string;
}

interface PeopleMasterFile {
  people: PersonMasterRecord[];
  metadata?: {
    tool_source?: ToolCode;
    batch_id?: string;
    uploaded_by?: string;
    total_records?: number;
  };
}

/**
 * Validation Result Structure (Output)
 */
interface ValidationResult {
  record_index: number;
  unique_id?: string;
  full_name: string;
  company_unique_id: string;
  company_slot_unique_id?: string;
  slot_type: string;
  status: 'success' | 'failed';
  errors: string[];
  warnings: string[];
  normalized_data?: Partial<PersonMasterRecord>;
}

interface APIResponse {
  success: boolean;
  rows_validated: number;
  rows_failed: number;
  total_processed: number;
  details: ValidationResult[];
  metadata: {
    batch_id: string;
    processing_time_ms: number;
    tool_code: string;
    altitude: number;
    doctrine: string;
    timestamp: string;
  };
  error?: string;
}

// ==============================================================================
// MAIN API HANDLER
// ==============================================================================

export default async function handler(
  req: NextApiRequest,
  res: NextApiResponse<APIResponse>
) {
  // Set CORS headers
  res.setHeader('Access-Control-Allow-Origin', '*');
  res.setHeader('Access-Control-Allow-Methods', 'POST, OPTIONS');
  res.setHeader('Access-Control-Allow-Headers', 'Content-Type, Authorization');

  if (req.method === 'OPTIONS') {
    return res.status(200).end();
  }

  if (req.method !== 'POST') {
    return res.status(405).json({
      success: false,
      rows_validated: 0,
      rows_failed: 0,
      total_processed: 0,
      details: [],
      error: 'Method not allowed. Only POST requests accepted.',
      metadata: {
        batch_id: '',
        processing_time_ms: 0,
        tool_code: '07', // Default to Apify for people
        altitude: 10000,
        doctrine: 'STAMPED',
        timestamp: new Date().toISOString()
      }
    });
  }

  const startTime = Date.now();
  const bridge = new StandardComposioNeonBridge();

  try {
    console.log('[VALIDATE-PEOPLE] Starting people validation process via Composio MCP');

    // Parse and validate input
    const masterFile = req.body as PeopleMasterFile;

    if (!masterFile.people || !Array.isArray(masterFile.people)) {
      throw new Error('Invalid input: people array is required');
    }

    if (masterFile.people.length === 0) {
      throw new Error('Invalid input: people array cannot be empty');
    }

    // Determine tool source (default to Apify for people scraping)
    const toolSource = masterFile.metadata?.tool_source || 'apify';
    const toolCode = TOOL_CODES[toolSource];

    const batchId = masterFile.metadata?.batch_id ||
      `people_batch_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;

    console.log(`[VALIDATE-PEOPLE] Processing ${masterFile.people.length} people (batch: ${batchId}, tool: ${toolSource}) via Composio`);

    // Validate each person record
    const validationResults: ValidationResult[] = [];
    let validatedCount = 0;
    let failedCount = 0;

    for (let i = 0; i < masterFile.people.length; i++) {
      const record = masterFile.people[i];

      try {
        const result = await validateSinglePerson(bridge, record, i, toolCode, batchId);
        validationResults.push(result);

        if (result.status === 'success') {
          validatedCount++;
        } else {
          failedCount++;
        }

      } catch (error) {
        console.error(`[VALIDATE-PEOPLE] Critical error processing record ${i}:`, error);

        validationResults.push({
          record_index: i,
          full_name: `${record.first_name || 'Unknown'} ${record.last_name || ''}`.trim(),
          company_unique_id: record.company_unique_id || '',
          slot_type: record.slot_type || '',
          status: 'failed',
          errors: [`System error: ${error.message}`],
          warnings: []
        });
        failedCount++;
      }
    }

    const processingTime = Date.now() - startTime;

    console.log(`[VALIDATE-PEOPLE] Batch complete via Composio: ${validatedCount} validated, ${failedCount} failed (${processingTime}ms)`);

    return res.status(200).json({
      success: true,
      rows_validated: validatedCount,
      rows_failed: failedCount,
      total_processed: validationResults.length,
      details: validationResults,
      metadata: {
        batch_id: batchId,
        processing_time_ms: processingTime,
        tool_code: toolCode,
        altitude: 10000,
        doctrine: 'STAMPED',
        timestamp: new Date().toISOString()
      }
    });

  } catch (error) {
    console.error('[VALIDATE-PEOPLE] Process failed:', error);

    return res.status(500).json({
      success: false,
      rows_validated: 0,
      rows_failed: 0,
      total_processed: 0,
      details: [],
      error: error.message,
      metadata: {
        batch_id: '',
        processing_time_ms: Date.now() - startTime,
        tool_code: '07',
        altitude: 10000,
        doctrine: 'STAMPED',
        timestamp: new Date().toISOString()
      }
    });
  }
}

// ==============================================================================
// SINGLE PERSON VALIDATION
// ==============================================================================

/**
 * Validate and process a single person record
 * Enforces all Barton Doctrine requirements via Standard Composio MCP
 */
async function validateSinglePerson(
  bridge: StandardComposioNeonBridge,
  record: PersonMasterRecord,
  recordIndex: number,
  toolCode: string,
  batchId: string
): Promise<ValidationResult> {

  const result: ValidationResult = {
    record_index: recordIndex,
    full_name: `${record.first_name || ''} ${record.last_name || ''}`.trim(),
    company_unique_id: record.company_unique_id,
    slot_type: record.slot_type,
    status: 'success',
    errors: [],
    warnings: [],
    normalized_data: {}
  };

  try {
    // Step 1: Generate People Barton unique_id via Composio
    const peopleUniqueId = await generatePeopleBartonId(bridge, toolCode);
    result.unique_id = peopleUniqueId;

    // Step 2: Validate required fields
    const validation = validateRequiredFields(record);
    if (!validation.valid) {
      result.status = 'failed';
      result.errors.push(...validation.errors);

      // Log the failure via Composio
      await logPeopleAuditEntry(bridge, peopleUniqueId, record.company_unique_id, null,
        'validate', 'failed', 'field_validation_errors', { errors: validation.errors }, batchId);

      return result;
    }

    // Step 3: Resolve company_slot_unique_id via Composio
    const companySlotId = await resolveCompanySlot(bridge, record.company_unique_id, record.slot_type);
    if (!companySlotId) {
      result.status = 'failed';
      result.errors.push(`No active ${record.slot_type} slot found for company ${record.company_unique_id}`);

      await logPeopleAuditEntry(bridge, peopleUniqueId, record.company_unique_id, null,
        'validate', 'failed', 'slot_resolution_error',
        { slot_type: record.slot_type, company_id: record.company_unique_id }, batchId);

      return result;
    }

    result.company_slot_unique_id = companySlotId;

    // Step 4: Normalize data
    const normalized = normalizePeopleData(record);
    result.normalized_data = normalized.data;
    result.warnings.push(...normalized.warnings);

    // Step 5: Insert into people_raw_intake via Composio
    await insertPersonRecord(bridge, peopleUniqueId, record.company_unique_id, companySlotId, normalized.data, batchId);

    // Step 6: Mark slot as filled via Composio
    await markSlotAsFilled(bridge, companySlotId);

    // Step 7: Log successful validation via Composio
    await logPeopleAuditEntry(bridge, peopleUniqueId, record.company_unique_id, companySlotId,
      'insert', 'success', 'people_validator',
      { record_index: recordIndex, batch_id: batchId, slot_type: record.slot_type }, batchId);

    console.log(`[VALIDATE-PEOPLE] Successfully processed: ${result.full_name} → ${record.slot_type} (${peopleUniqueId})`);

    return result;

  } catch (error) {
    console.error(`[VALIDATE-PEOPLE] Error processing record ${recordIndex}:`, error);

    result.status = 'failed';
    result.errors.push(`Processing error: ${error.message}`);

    // Log the error if we have IDs
    if (result.unique_id) {
      try {
        await logPeopleAuditEntry(bridge, result.unique_id, record.company_unique_id, result.company_slot_unique_id,
          'validate', 'failed', 'system_error',
          { error: error.message, record_index: recordIndex }, batchId);
      } catch (logError) {
        console.error('[VALIDATE-PEOPLE] Failed to log error:', logError);
      }
    }

    return result;
  }
}

// ==============================================================================
// BARTON ID GENERATION VIA COMPOSIO
// ==============================================================================

/**
 * Generate 6-part Barton unique ID for people via Standard Composio MCP
 * Calls database function to ensure proper sequencing
 */
async function generatePeopleBartonId(bridge: StandardComposioNeonBridge, toolCode: string): Promise<string> {
  const query = 'SELECT generate_people_barton_id($1) as barton_id';

  try {
    const result = await bridge.query(query, [toolCode]);

    if (!result.rows || result.rows.length === 0) {
      throw new Error('Failed to generate People Barton ID: No result returned from Composio');
    }

    const bartonId = result.rows[0].barton_id;

    if (!bartonId || typeof bartonId !== 'string') {
      throw new Error('Failed to generate People Barton ID: Invalid result format from Composio');
    }

    console.log(`[VALIDATE-PEOPLE] Generated People Barton ID via Composio: ${bartonId}`);
    return bartonId;

  } catch (error) {
    console.error('[VALIDATE-PEOPLE] People Barton ID generation failed via Composio:', error);
    throw new Error(`People Barton ID generation failed: ${error.message}`);
  }
}

// ==============================================================================
// FIELD VALIDATION
// ==============================================================================

/**
 * Validate required fields per Barton Doctrine requirements
 * Enforces Company → Slot → Person linkage
 */
function validateRequiredFields(record: PersonMasterRecord): { valid: boolean; errors: string[] } {
  const errors: string[] = [];

  // Required linkage fields
  if (!record.company_unique_id || record.company_unique_id.trim().length === 0) {
    errors.push('company_unique_id is required for person linkage');
  }

  if (!record.slot_type || record.slot_type.trim().length === 0) {
    errors.push('slot_type is required for person assignment');
  }

  // Validate slot_type enum
  const validSlotTypes = ['CEO', 'CFO', 'HR', 'CTO', 'CMO', 'COO', 'VP_SALES', 'VP_MARKETING', 'DIRECTOR', 'MANAGER'];
  if (record.slot_type && !validSlotTypes.includes(record.slot_type)) {
    errors.push(`Invalid slot_type: ${record.slot_type}. Must be one of: ${validSlotTypes.join(', ')}`);
  }

  // Required person fields
  if (!record.first_name || record.first_name.trim().length === 0) {
    errors.push('first_name is required and cannot be empty');
  }

  if (!record.last_name || record.last_name.trim().length === 0) {
    errors.push('last_name is required and cannot be empty');
  }

  // Validate seniority enum if provided
  if (record.seniority) {
    const validSeniorities = ['C-Level', 'VP-Level', 'Director-Level', 'Manager-Level', 'Individual Contributor', 'Entry-Level'];
    if (!validSeniorities.includes(record.seniority)) {
      errors.push(`Invalid seniority: ${record.seniority}. Must be one of: ${validSeniorities.join(', ')}`);
    }
  }

  // Require either email OR phone (at least one contact method)
  const hasValidEmail = record.email && record.email.trim().length > 0;
  const hasValidPhone = (record.work_phone_e164 && record.work_phone_e164.trim().length > 0) ||
                        (record.personal_phone_e164 && record.personal_phone_e164.trim().length > 0);

  if (!hasValidEmail && !hasValidPhone) {
    errors.push('Either email or phone number is required');
  }

  // Validate email format if provided
  if (hasValidEmail) {
    const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
    if (!emailRegex.test(record.email)) {
      errors.push('email must be a valid email address format');
    }
  }

  return { valid: errors.length === 0, errors };
}

// ==============================================================================
// DATA NORMALIZATION
// ==============================================================================

/**
 * Normalize people data for database storage
 * Handles phone number E.164 conversion and field sanitization
 */
function normalizePeopleData(record: PersonMasterRecord): {
  data: PersonMasterRecord;
  warnings: string[]
} {
  const warnings: string[] = [];
  const normalized = { ...record };

  // Normalize phone numbers to E.164 format
  if (normalized.work_phone_e164) {
    try {
      normalized.work_phone_e164 = normalizePhoneToE164(normalized.work_phone_e164);
    } catch (error) {
      warnings.push(`Work phone normalization warning: ${error.message}`);
    }
  }

  if (normalized.personal_phone_e164) {
    try {
      normalized.personal_phone_e164 = normalizePhoneToE164(normalized.personal_phone_e164);
    } catch (error) {
      warnings.push(`Personal phone normalization warning: ${error.message}`);
    }
  }

  // Trim string fields
  const stringFields = [
    'first_name', 'last_name', 'title', 'department', 'email',
    'linkedin_url', 'twitter_url', 'facebook_url', 'bio', 'skills', 'education', 'certifications'
  ];

  for (const field of stringFields) {
    if (normalized[field] && typeof normalized[field] === 'string') {
      normalized[field] = normalized[field].trim();
    }
  }

  return { data: normalized, warnings };
}

/**
 * Convert phone number to E.164 format
 */
function normalizePhoneToE164(phone: string): string {
  if (!phone) return '';

  // Remove all non-digit characters
  const digits = phone.replace(/\D/g, '');

  // US number handling
  if (digits.length === 10) {
    return `+1${digits}`;
  }

  if (digits.length === 11 && digits.startsWith('1')) {
    return `+${digits}`;
  }

  // Already in E.164 format
  if (phone.startsWith('+')) {
    return phone;
  }

  // Default: assume US if no country code
  if (digits.length >= 10) {
    const last10 = digits.slice(-10);
    return `+1${last10}`;
  }

  throw new Error(`Invalid phone number format: ${phone}`);
}

// ==============================================================================
// DATABASE OPERATIONS VIA COMPOSIO
// ==============================================================================

/**
 * Resolve company slot ID via Standard Composio MCP
 * Finds company_slot_unique_id for given company + slot_type
 */
async function resolveCompanySlot(
  bridge: StandardComposioNeonBridge,
  companyUniqueId: string,
  slotType: string
): Promise<string | null> {

  const query = `
    SELECT company_slot_unique_id
    FROM marketing.company_slot
    WHERE company_unique_id = $1
      AND slot_type = $2
      AND slot_status = 'active'
  `;

  try {
    const result = await bridge.query(query, [companyUniqueId, slotType]);

    if (!result.rows || result.rows.length === 0) {
      console.warn(`[VALIDATE-PEOPLE] No active slot found: company=${companyUniqueId}, slot_type=${slotType}`);
      return null;
    }

    const slotId = result.rows[0].company_slot_unique_id;
    console.log(`[VALIDATE-PEOPLE] Resolved slot via Composio: ${slotId} (${slotType})`);
    return slotId;

  } catch (error) {
    console.error('[VALIDATE-PEOPLE] Slot resolution failed via Composio:', error);
    return null;
  }
}

/**
 * Insert person record into marketing.people_raw_intake via Composio
 */
async function insertPersonRecord(
  bridge: StandardComposioNeonBridge,
  uniqueId: string,
  companyUniqueId: string,
  companySlotUniqueId: string,
  data: PersonMasterRecord,
  batchId: string
): Promise<void> {

  const query = `
    INSERT INTO marketing.people_raw_intake (
      unique_id,
      company_unique_id,
      company_slot_unique_id,
      first_name,
      last_name,
      title,
      seniority,
      department,
      email,
      work_phone_e164,
      personal_phone_e164,
      linkedin_url,
      twitter_url,
      facebook_url,
      bio,
      skills,
      education,
      certifications,
      source_system,
      source_record_id,
      validation_status,
      altitude,
      process_step
    ) VALUES (
      $1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15, $16, $17, $18, $19, $20, $21, $22, $23
    )
  `;

  const params = [
    uniqueId,
    companyUniqueId,
    companySlotUniqueId,
    data.first_name,
    data.last_name,
    data.title || null,
    data.seniority || null,
    data.department || null,
    data.email || null,
    data.work_phone_e164 || null,
    data.personal_phone_e164 || null,
    data.linkedin_url || null,
    data.twitter_url || null,
    data.facebook_url || null,
    data.bio || null,
    data.skills || null,
    data.education || null,
    data.certifications || null,
    data.source_system || 'people_validator',
    data.source_record_id || batchId,
    'validated',
    10000,
    'people_intake_validation'
  ];

  try {
    await bridge.query(query, params);
    console.log(`[VALIDATE-PEOPLE] Inserted person via Composio: ${uniqueId}`);
  } catch (error) {
    console.error(`[VALIDATE-PEOPLE] Failed to insert person ${uniqueId} via Composio:`, error);
    throw new Error(`Database insert failed: ${error.message}`);
  }
}

/**
 * Mark company slot as filled via Composio MCP
 */
async function markSlotAsFilled(bridge: StandardComposioNeonBridge, slotUniqueId: string): Promise<void> {
  const query = `
    UPDATE marketing.company_slot
    SET is_filled = TRUE, updated_at = NOW()
    WHERE company_slot_unique_id = $1
  `;

  try {
    await bridge.query(query, [slotUniqueId]);
    console.log(`[VALIDATE-PEOPLE] Marked slot as filled via Composio: ${slotUniqueId}`);
  } catch (error) {
    console.error(`[VALIDATE-PEOPLE] Failed to mark slot as filled via Composio: ${slotUniqueId}`, error);
    // Don't throw - this is not critical for validation success
  }
}

/**
 * Log audit entry to marketing.people_audit_log via Composio
 * Required for Barton Doctrine compliance
 */
async function logPeopleAuditEntry(
  bridge: StandardComposioNeonBridge,
  uniqueId: string,
  companyUniqueId: string,
  companySlotUniqueId: string | null,
  action: string,
  status: string,
  source: string,
  metadata: any,
  sessionId: string
): Promise<void> {

  const query = `
    INSERT INTO marketing.people_audit_log (
      unique_id,
      company_unique_id,
      company_slot_unique_id,
      action,
      status,
      source,
      error_log,
      new_values,
      altitude,
      process_id,
      session_id
    ) VALUES (
      $1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11
    )
  `;

  const params = [
    uniqueId,
    companyUniqueId,
    companySlotUniqueId,
    action,
    status,
    source,
    status === 'failed' ? JSON.stringify(metadata) : null,
    status === 'success' ? JSON.stringify(metadata) : null,
    10000,
    'people_validator_api',
    sessionId
  ];

  try {
    await bridge.query(query, params);
  } catch (error) {
    console.error(`[VALIDATE-PEOPLE] Failed to log audit entry for ${uniqueId} via Composio:`, error);
    // Don't throw - audit logging failures shouldn't break the main process
  }
}