#!/bin/bash
# CTB Structure Enforcement - Pre-commit Hook
# Automatically tags new files and validates CTB compliance before allowing commits

set -e

echo "🔍 CTB Structure Enforcement - Validating commit..."

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

# Get repository root
REPO_ROOT=$(git rev-parse --show-toplevel)
cd "$REPO_ROOT"

# Check if Python is available
if ! command -v python &> /dev/null && ! command -v python3 &> /dev/null; then
    echo -e "${RED}❌ ERROR: Python not found. Install Python to use CTB enforcement.${NC}"
    exit 1
fi

PYTHON_CMD=$(command -v python3 &> /dev/null && echo "python3" || echo "python")

# Paths to enforcement scripts
TAGGER_SCRIPT="ctb/sys/github-factory/scripts/ctb_metadata_tagger.py"
AUDIT_SCRIPT="ctb/sys/github-factory/scripts/ctb_audit_generator.py"

# Check if scripts exist
if [ ! -f "$TAGGER_SCRIPT" ]; then
    echo -e "${RED}❌ ERROR: CTB tagger script not found at $TAGGER_SCRIPT${NC}"
    exit 1
fi

if [ ! -f "$AUDIT_SCRIPT" ]; then
    echo -e "${RED}❌ ERROR: CTB audit script not found at $AUDIT_SCRIPT${NC}"
    exit 1
fi

# Step 1: Auto-tag new files in staged changes
echo -e "${BLUE}Step 1/3: Auto-tagging new files...${NC}"

# Get list of staged files (new and modified)
STAGED_FILES=$(git diff --cached --name-only --diff-filter=ACM)

if [ -z "$STAGED_FILES" ]; then
    echo -e "${YELLOW}⚠️  No files staged for commit.${NC}"
    exit 0
fi

# Check for new files that need tagging
NEW_FILES=$(git diff --cached --name-only --diff-filter=A)

if [ -n "$NEW_FILES" ]; then
    echo -e "${YELLOW}Found new files to tag:${NC}"
    echo "$NEW_FILES"

    # Run tagger on new files
    for file in $NEW_FILES; do
        # Skip certain directories/files
        if [[ "$file" == node_modules/* ]] || \
           [[ "$file" == .git/* ]] || \
           [[ "$file" == *.min.js ]] || \
           [[ "$file" == *.min.css ]] || \
           [[ "$file" == package-lock.json ]] || \
           [[ "$file" == *.log ]] || \
           [[ "$file" == .env* ]] && [[ "$file" != *.env.example ]]; then
            continue
        fi

        # Only tag files in ctb/ directory
        if [[ "$file" == ctb/* ]]; then
            echo -e "${BLUE}  Tagging: $file${NC}"
            $PYTHON_CMD "$TAGGER_SCRIPT" "$file" 2>/dev/null || true

            # Re-stage the file if it was modified by tagger
            if [ -f "$file" ]; then
                git add "$file"
            fi
        fi
    done

    echo -e "${GREEN}✓ Auto-tagging complete${NC}"
else
    echo -e "${GREEN}✓ No new files to tag${NC}"
fi

# Step 2: Run CTB compliance audit
echo -e "\n${BLUE}Step 2/3: Running CTB compliance audit...${NC}"

# Create temporary file for audit output
AUDIT_OUTPUT=$(mktemp)

# Run audit and capture output
if $PYTHON_CMD "$AUDIT_SCRIPT" "ctb/" > "$AUDIT_OUTPUT" 2>&1; then
    AUDIT_RESULT=$?
else
    AUDIT_RESULT=$?
fi

# Parse compliance score from output
COMPLIANCE_SCORE=$(grep -oP "CTB Compliance Score: \K\d+" "$AUDIT_OUTPUT" 2>/dev/null || echo "0")
COMPLIANCE_GRADE=$(grep -oP "CTB Compliance Score: \d+/100 \(\K[A-Z]+" "$AUDIT_OUTPUT" 2>/dev/null || echo "FAIL")

echo -e "\n${BLUE}Compliance Score: $COMPLIANCE_SCORE/100 ($COMPLIANCE_GRADE)${NC}"

# Step 3: Validate compliance threshold
echo -e "\n${BLUE}Step 3/3: Validating compliance threshold...${NC}"

MIN_COMPLIANCE_SCORE=70  # Minimum required score

if [ "$COMPLIANCE_SCORE" -lt "$MIN_COMPLIANCE_SCORE" ]; then
    echo -e "\n${RED}═══════════════════════════════════════════════════════${NC}"
    echo -e "${RED}❌ COMMIT BLOCKED - CTB Compliance Below Threshold${NC}"
    echo -e "${RED}═══════════════════════════════════════════════════════${NC}"
    echo -e "${YELLOW}Current Score: $COMPLIANCE_SCORE/100${NC}"
    echo -e "${YELLOW}Required Score: $MIN_COMPLIANCE_SCORE/100${NC}"
    echo -e "\n${YELLOW}To fix:${NC}"
    echo -e "  1. Run: ${BLUE}python ctb/sys/github-factory/scripts/ctb_remediation.py ctb/${NC}"
    echo -e "  2. Review and commit fixes"
    echo -e "  3. Try committing again"
    echo -e "\n${YELLOW}To bypass (NOT RECOMMENDED):${NC}"
    echo -e "  ${BLUE}git commit --no-verify${NC}"
    echo -e "${RED}═══════════════════════════════════════════════════════${NC}"

    # Clean up
    rm -f "$AUDIT_OUTPUT"
    exit 1
fi

# Step 4: Check for specific violations
echo -e "${BLUE}Checking for critical violations...${NC}"

# Check for missing Barton IDs in staged ctb/ files
MISSING_IDS=0
for file in $STAGED_FILES; do
    if [[ "$file" == ctb/* ]] && [ -f "$file" ]; then
        # Skip binary files and non-text files
        if file "$file" | grep -q "text"; then
            # Check if file has Barton ID
            if ! grep -q "Barton ID:" "$file" 2>/dev/null; then
                echo -e "${YELLOW}  ⚠️  Missing Barton ID: $file${NC}"
                MISSING_IDS=$((MISSING_IDS + 1))
            fi
        fi
    fi
done

if [ "$MISSING_IDS" -gt 0 ]; then
    echo -e "\n${YELLOW}⚠️  Warning: $MISSING_IDS file(s) missing Barton IDs${NC}"
    echo -e "${YELLOW}   These files will be auto-tagged, but please verify.${NC}"
fi

# Success
echo -e "\n${GREEN}═══════════════════════════════════════════════════════${NC}"
echo -e "${GREEN}✓ CTB Compliance Validation Passed${NC}"
echo -e "${GREEN}═══════════════════════════════════════════════════════${NC}"
echo -e "${GREEN}Score: $COMPLIANCE_SCORE/100 ($COMPLIANCE_GRADE)${NC}"
echo -e "${GREEN}All files properly tagged and compliant.${NC}"
echo -e "${GREEN}═══════════════════════════════════════════════════════${NC}\n"

# Clean up
rm -f "$AUDIT_OUTPUT"

exit 0
