# Node 1 Tools - Neon Functions + CI Checks
# Database functions and CI validation tools

version: "1.0"
node: "node-1-company-db"
altitude: "30k"

# Neon Database Functions
database_functions:
  - name: "gen_company_uid"
    type: "function"
    returns: "text"
    description: "Generate unique company UID (CO-YYYYMMDD-######)"
    implementation: |
      CREATE OR REPLACE FUNCTION marketing.gen_company_uid()
      RETURNS text AS $$
      DECLARE
        date_part text;
        seq_num bigint;
        result text;
      BEGIN
        date_part := TO_CHAR(CURRENT_DATE, 'YYYYMMDD');
        seq_num := nextval('marketing.company_uid_seq');
        result := 'CO-' || date_part || '-' || LPAD(seq_num::text, 6, '0');
        RETURN result;
      END;
      $$ LANGUAGE plpgsql;

  - name: "gen_slot_uid"
    type: "function"
    returns: "text"
    parameters:
      - name: "company_uid"
        type: "text"
      - name: "role"
        type: "text"
    description: "Generate slot UID (SL-<company_uid>-<role>)"
    implementation: |
      CREATE OR REPLACE FUNCTION marketing.gen_slot_uid(company_uid text, role text)
      RETURNS text AS $$
      BEGIN
        RETURN 'SL-' || company_uid || '-' || UPPER(role);
      END;
      $$ LANGUAGE plpgsql;

  - name: "insert_company_with_slots"
    type: "function"
    returns: "json"
    parameters:
      - name: "company_name"
        type: "text"
      - name: "website"
        type: "text"
      - name: "apollo_company_id"
        type: "text"
      - name: "ein_raw"
        type: "text"
    description: "Insert company and create 3 role slots atomically"
    implementation: |
      CREATE OR REPLACE FUNCTION marketing.insert_company_with_slots(
        company_name text,
        website text,
        apollo_company_id text DEFAULT NULL,
        ein_raw text DEFAULT NULL
      )
      RETURNS json AS $$
      DECLARE
        new_company_uid text;
        company_record record;
        slot_records json[];
        role_list text[] := ARRAY['CEO', 'CFO', 'HR'];
        role text;
      BEGIN
        -- Check for existing company
        SELECT company_uid INTO new_company_uid
        FROM marketing.company
        WHERE LOWER(website) = LOWER(insert_company_with_slots.website)
        LIMIT 1;
        
        IF new_company_uid IS NOT NULL THEN
          RETURN json_build_object(
            'status', 'exists',
            'company_uid', new_company_uid,
            'message', 'Company already exists'
          );
        END IF;
        
        -- Generate new UID and insert company
        new_company_uid := marketing.gen_company_uid();
        
        INSERT INTO marketing.company (
          company_uid, company_name, website, 
          apollo_company_id, ein_raw, created_at
        ) VALUES (
          new_company_uid, company_name, website,
          apollo_company_id, ein_raw, NOW()
        ) RETURNING * INTO company_record;
        
        -- Create slots for each role
        FOREACH role IN ARRAY role_list LOOP
          INSERT INTO marketing.company_slot (
            slot_uid, company_uid, role, 
            status, created_at
          ) VALUES (
            marketing.gen_slot_uid(new_company_uid, role),
            new_company_uid,
            role,
            'open',
            NOW()
          );
        END LOOP;
        
        RETURN json_build_object(
          'status', 'created',
          'company_uid', new_company_uid,
          'slots_created', 3
        );
      END;
      $$ LANGUAGE plpgsql;

# CI Check Tools
ci_checks:
  - name: "ddl-validate"
    type: "sql_validation"
    description: "Validate DDL syntax without execution"
    command: "psql --set ON_ERROR_STOP=1 -f schema/001_init.sql --dry-run"
    expected_output: "No syntax errors"
    
  - name: "orbt-check"
    type: "pr_template_validation"
    description: "Verify ORBT sections in PR template"
    required_sections:
      - "## Operate"
      - "## Repair"
      - "## Build"
      - "## Train"
    command: "grep -E '## (Operate|Repair|Build|Train)' .github/pull_request_template.md"
    
  - name: "lint"
    type: "code_quality"
    description: "Basic formatting and style checks"
    tools:
      - tool: "prettier"
        config: ".prettierrc"
        files: "**/*.{js,ts,yaml,yml,json}"
      - tool: "sqlfluff"
        config: ".sqlfluff"
        files: "**/*.sql"

# Test Helpers
test_helpers:
  - name: "test_uid_generation"
    type: "unit_test"
    description: "Test UID generation functions"
    test_cases:
      - input: "SELECT marketing.gen_company_uid();"
        expected_pattern: "^CO-\\d{8}-\\d{6}$"
      - input: "SELECT marketing.gen_slot_uid('CO-20240101-000001', 'CEO');"
        expected: "SL-CO-20240101-000001-CEO"

  - name: "test_idempotency"
    type: "integration_test"
    description: "Test idempotent company insertion"
    test_script: |
      -- Insert company first time
      SELECT marketing.insert_company_with_slots('Test Corp', 'test.com');
      -- Try to insert again - should return 'exists' status
      SELECT marketing.insert_company_with_slots('Test Corp', 'test.com');

# Monitoring Queries
monitoring:
  - name: "company_count"
    query: "SELECT COUNT(*) FROM marketing.company"
    
  - name: "slot_distribution"
    query: |
      SELECT role, COUNT(*) as count
      FROM marketing.company_slot
      GROUP BY role
      
  - name: "recent_insertions"
    query: |
      SELECT company_uid, company_name, created_at
      FROM marketing.company
      WHERE created_at > NOW() - INTERVAL '1 hour'
      ORDER BY created_at DESC
      LIMIT 10

# Dead Letter Queue
dead_letter:
  table: "marketing.dead_letter_queue"
  schema: |
    CREATE TABLE IF NOT EXISTS marketing.dead_letter_queue (
      id SERIAL PRIMARY KEY,
      source_file text,
      row_number integer,
      raw_data text,
      error_message text,
      created_at timestamp DEFAULT NOW()
    );