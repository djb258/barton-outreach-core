/**
 * FailureRecord
 * =============
 * Data models for the Failure Routing System (Garage → Bays model).
 *
 * Each failure type corresponds to a Neon table:
 * - company_fuzzy_failures
 * - person_company_mismatch
 * - email_pattern_failures
 * - email_generation_failures
 * - linkedin_resolution_failures
 * - slot_discovery_failures
 * - dol_sync_failures
 * - agent_failures (catch-all)
 *
 * Purpose: Enable SELECT → REPROCESS repair workflow
 */

import { SlotRow } from "./SlotRow";

/**
 * Failure bay identifiers (table names).
 */
export type FailureBay =
  | "company_fuzzy_failures"
  | "person_company_mismatch"
  | "email_pattern_failures"
  | "email_generation_failures"
  | "linkedin_resolution_failures"
  | "slot_discovery_failures"
  | "dol_sync_failures"
  | "agent_failures";

/**
 * Node identifiers.
 */
export type FailureNode = "COMPANY_HUB" | "PEOPLE_NODE" | "DOL_NODE" | "BIT_NODE";

/**
 * Agent type identifiers.
 */
export type FailureAgentType =
  | "CompanyFuzzyMatchAgent"
  | "TitleCompanyAgent"
  | "PeopleFuzzyMatchAgent"
  | "PatternAgent"
  | "EmailGeneratorAgent"
  | "LinkedInFinderAgent"
  | "MissingSlotAgent"
  | "DOLSyncAgent"
  | "PublicScannerAgent"
  | "MovementHashAgent"
  | "BITScoreAgent"
  | "Unknown";

/**
 * Error type categories.
 */
export type FailureErrorType =
  | "validation"
  | "api"
  | "timeout"
  | "rate_limit"
  | "cost_limit"
  | "budget_exceeded"
  | "circuit_breaker"
  | "cooldown"
  | "vendor_disabled"
  | "throttle"
  | "not_found"
  | "mismatch"
  | "parse"
  | "unknown";

/**
 * Base failure record interface.
 */
export interface BaseFailureRecord {
  /** UUID (generated by Neon) */
  id?: string;
  /** Reason for failure */
  reason: string;
  /** Timestamp */
  created_at?: Date;
  /** Repair timestamp (null if not repaired) - DEPRECATED: use resolved_at */
  repaired_at?: Date | null;
  /** Repair notes */
  repair_notes?: string | null;
  /** Whether this failure has been resolved */
  resolved?: boolean;
  /** Timestamp when resolved */
  resolved_at?: Date | null;
  /** Node to resume execution from */
  resume_node?: string;
  /** Agent to resume execution from within the node */
  resume_agent?: string;
  /** Number of retry attempts */
  attempts?: number;
  /** Last attempt timestamp */
  last_attempt_at?: Date | null;
  /** Fixed slot row data for re-processing */
  fixed_slot_row?: Record<string, unknown> | null;
}

/**
 * Company Fuzzy Match Failure Record.
 * Bay: company_fuzzy_failures
 */
export interface CompanyFuzzyFailure extends BaseFailureRecord {
  slot_row_id: string;
  slot_row: SlotRow | Record<string, unknown>;
  raw_company_input: string;
  best_match: string | null;
  match_score: number;
  match_status: "UNMATCHED" | "MANUAL_REVIEW";
  candidates: Array<{ company: string; score: number }>;
}

/**
 * Person-Company Mismatch Failure Record.
 * Bay: person_company_mismatch
 */
export interface PersonCompanyMismatchFailure extends BaseFailureRecord {
  slot_row_id: string;
  slot_row: SlotRow | Record<string, unknown>;
  person_name: string | null;
  canonical_company: string;
  detected_employer: string | null;
  match_score: number;
  threshold: number;
  linkedin_url: string | null;
}

/**
 * Email Pattern Failure Record.
 * Bay: email_pattern_failures
 */
export interface EmailPatternFailure extends BaseFailureRecord {
  slot_row_id: string;
  slot_row: SlotRow | Record<string, unknown>;
  company_name: string;
  company_domain: string | null;
  attempted_sources: string[];
  fallback_used: boolean;
}

/**
 * Email Generation Failure Record.
 * Bay: email_generation_failures
 */
export interface EmailGenerationFailure extends BaseFailureRecord {
  slot_row_id: string;
  slot_row: SlotRow | Record<string, unknown>;
  person_name: string | null;
  company_name: string;
  company_domain: string | null;
  email_pattern: string | null;
  attempted_email: string | null;
  verification_status: string | null;
  validation_flags: {
    company_valid: boolean;
    person_company_valid: boolean;
    skip_email: boolean;
    skip_reason: string | null;
  };
}

/**
 * LinkedIn Resolution Failure Record.
 * Bay: linkedin_resolution_failures
 */
export interface LinkedInResolutionFailure extends BaseFailureRecord {
  slot_row_id: string;
  slot_row: SlotRow | Record<string, unknown>;
  person_name: string;
  company_name: string;
  slot_type: string;
  attempted_sources: string[];
}

/**
 * Slot Discovery Failure Record.
 * Bay: slot_discovery_failures
 */
export interface SlotDiscoveryFailure extends BaseFailureRecord {
  company_id: string;
  company_name: string;
  slot_type: string;
  discovery_method: string | null;
  metadata: Record<string, unknown>;
}

/**
 * DOL Sync Failure Record.
 * Bay: dol_sync_failures
 */
export interface DOLSyncFailure extends BaseFailureRecord {
  company_id: string;
  company_name: string;
  ein: string | null;
  sync_type: string;
  api_response: Record<string, unknown> | null;
}

/**
 * Generic Agent Failure Record.
 * Bay: agent_failures (catch-all)
 */
export interface AgentFailure extends BaseFailureRecord {
  node_id: FailureNode;
  agent_type: FailureAgentType;
  slot_row_id: string | null;
  slot_row: SlotRow | Record<string, unknown> | null;
  task_id: string | null;
  error_type: FailureErrorType;
  stack_trace: string | null;
  metadata: Record<string, unknown>;
}

/**
 * Union type of all failure records.
 */
export type FailureRecord =
  | CompanyFuzzyFailure
  | PersonCompanyMismatchFailure
  | EmailPatternFailure
  | EmailGenerationFailure
  | LinkedInResolutionFailure
  | SlotDiscoveryFailure
  | DOLSyncFailure
  | AgentFailure;

/**
 * Failure routing result.
 */
export interface FailureRoutingResult {
  success: boolean;
  bay: FailureBay;
  record_id?: string;
  error?: string;
}

/**
 * Agent failure bay mapping.
 * Maps agent types to their dedicated failure tables.
 */
export const AGENT_FAILURE_BAY_MAP: Record<FailureAgentType, FailureBay> = {
  CompanyFuzzyMatchAgent: "company_fuzzy_failures",
  TitleCompanyAgent: "person_company_mismatch",
  PeopleFuzzyMatchAgent: "person_company_mismatch",
  PatternAgent: "email_pattern_failures",
  EmailGeneratorAgent: "email_generation_failures",
  LinkedInFinderAgent: "linkedin_resolution_failures",
  MissingSlotAgent: "slot_discovery_failures",
  DOLSyncAgent: "dol_sync_failures",
  PublicScannerAgent: "agent_failures",
  MovementHashAgent: "agent_failures",
  BITScoreAgent: "agent_failures",
  Unknown: "agent_failures",
};

/**
 * Resume point mapping for each failure bay.
 * Defines where to resume execution after a failure is repaired.
 */
export interface ResumePoint {
  resume_node: FailureNode;
  resume_agent: FailureAgentType;
}

export const FAILURE_RESUME_POINTS: Record<FailureBay, ResumePoint> = {
  company_fuzzy_failures: {
    resume_node: "COMPANY_HUB",
    resume_agent: "CompanyFuzzyMatchAgent",
  },
  person_company_mismatch: {
    resume_node: "PEOPLE_NODE",
    resume_agent: "PeopleFuzzyMatchAgent",
  },
  email_pattern_failures: {
    resume_node: "COMPANY_HUB",
    resume_agent: "PatternAgent",
  },
  email_generation_failures: {
    resume_node: "COMPANY_HUB",
    resume_agent: "EmailGeneratorAgent",
  },
  linkedin_resolution_failures: {
    resume_node: "PEOPLE_NODE",
    resume_agent: "LinkedInFinderAgent",
  },
  slot_discovery_failures: {
    resume_node: "COMPANY_HUB",
    resume_agent: "MissingSlotAgent",
  },
  dol_sync_failures: {
    resume_node: "DOL_NODE",
    resume_agent: "DOLSyncAgent",
  },
  agent_failures: {
    resume_node: "COMPANY_HUB",
    resume_agent: "Unknown",
  },
};

/**
 * Get the resume point for a failure bay.
 */
export function getResumePointForBay(bay: FailureBay): ResumePoint {
  return FAILURE_RESUME_POINTS[bay];
}

/**
 * Get the failure bay for an agent type.
 */
export function getFailureBayForAgent(agentType: string): FailureBay {
  return AGENT_FAILURE_BAY_MAP[agentType as FailureAgentType] || "agent_failures";
}

/**
 * Create a company fuzzy failure record.
 */
export function createCompanyFuzzyFailure(
  row: SlotRow,
  rawInput: string,
  bestMatch: string | null,
  matchScore: number,
  matchStatus: "UNMATCHED" | "MANUAL_REVIEW",
  candidates: Array<{ company: string; score: number }>,
  reason: string
): CompanyFuzzyFailure {
  return {
    slot_row_id: row.id,
    slot_row: row,
    raw_company_input: rawInput,
    best_match: bestMatch,
    match_score: matchScore,
    match_status: matchStatus,
    candidates,
    reason,
  };
}

/**
 * Create a person-company mismatch failure record.
 */
export function createPersonCompanyMismatchFailure(
  row: SlotRow,
  canonicalCompany: string,
  detectedEmployer: string | null,
  matchScore: number,
  threshold: number,
  reason: string
): PersonCompanyMismatchFailure {
  return {
    slot_row_id: row.id,
    slot_row: row,
    person_name: row.person_name,
    canonical_company: canonicalCompany,
    detected_employer: detectedEmployer,
    match_score: matchScore,
    threshold,
    linkedin_url: row.linkedin_url,
    reason,
  };
}

/**
 * Create an email pattern failure record.
 */
export function createEmailPatternFailure(
  row: SlotRow,
  companyName: string,
  companyDomain: string | null,
  attemptedSources: string[],
  fallbackUsed: boolean,
  reason: string
): EmailPatternFailure {
  return {
    slot_row_id: row.id,
    slot_row: row,
    company_name: companyName,
    company_domain: companyDomain,
    attempted_sources: attemptedSources,
    fallback_used: fallbackUsed,
    reason,
  };
}

/**
 * Create an email generation failure record.
 */
export function createEmailGenerationFailure(
  row: SlotRow,
  attemptedEmail: string | null,
  verificationStatus: string | null,
  reason: string
): EmailGenerationFailure {
  return {
    slot_row_id: row.id,
    slot_row: row,
    person_name: row.person_name,
    company_name: row.company_name || "",
    company_domain: (row as any).company_domain || null,
    email_pattern: row.email_pattern,
    attempted_email: attemptedEmail,
    verification_status: verificationStatus,
    validation_flags: {
      company_valid: row.company_valid,
      person_company_valid: row.person_company_valid,
      skip_email: row.skip_email,
      skip_reason: row.skip_reason,
    },
    reason,
  };
}

/**
 * Create a LinkedIn resolution failure record.
 */
export function createLinkedInResolutionFailure(
  row: SlotRow,
  attemptedSources: string[],
  reason: string
): LinkedInResolutionFailure {
  return {
    slot_row_id: row.id,
    slot_row: row,
    person_name: row.person_name || "",
    company_name: row.company_name || "",
    slot_type: row.slot_type,
    attempted_sources: attemptedSources,
    reason,
  };
}

/**
 * Create a slot discovery failure record.
 */
export function createSlotDiscoveryFailure(
  companyId: string,
  companyName: string,
  slotType: string,
  discoveryMethod: string | null,
  reason: string,
  metadata: Record<string, unknown> = {}
): SlotDiscoveryFailure {
  return {
    company_id: companyId,
    company_name: companyName,
    slot_type: slotType,
    discovery_method: discoveryMethod,
    metadata,
    reason,
  };
}

/**
 * Create a DOL sync failure record.
 */
export function createDOLSyncFailure(
  companyId: string,
  companyName: string,
  ein: string | null,
  syncType: string,
  reason: string,
  apiResponse: Record<string, unknown> | null = null
): DOLSyncFailure {
  return {
    company_id: companyId,
    company_name: companyName,
    ein,
    sync_type: syncType,
    api_response: apiResponse,
    reason,
  };
}

/**
 * Create a generic agent failure record.
 */
export function createAgentFailure(
  nodeId: FailureNode,
  agentType: FailureAgentType,
  reason: string,
  options: {
    slot_row_id?: string;
    slot_row?: SlotRow | Record<string, unknown>;
    task_id?: string;
    error_type?: FailureErrorType;
    stack_trace?: string;
    metadata?: Record<string, unknown>;
  } = {}
): AgentFailure {
  return {
    node_id: nodeId,
    agent_type: agentType,
    slot_row_id: options.slot_row_id || null,
    slot_row: options.slot_row || null,
    task_id: options.task_id || null,
    error_type: options.error_type || "unknown",
    stack_trace: options.stack_trace || null,
    metadata: options.metadata || {},
    reason,
  };
}

/**
 * Serialize a SlotRow for JSONB storage.
 */
export function serializeSlotRow(row: SlotRow): Record<string, unknown> {
  return {
    id: row.id,
    company_id: row.company_id,
    company_name: row.company_name,
    slot_type: row.slot_type,
    person_name: row.person_name,
    linkedin_url: row.linkedin_url,
    email: row.email,
    email_pattern: row.email_pattern,
    email_verified: row.email_verified,
    current_title: row.current_title,
    current_company: row.current_company,
    company_valid: row.company_valid,
    company_invalid_reason: row.company_invalid_reason,
    person_company_valid: row.person_company_valid,
    person_company_match_score: row.person_company_match_score,
    skip_email: row.skip_email,
    skip_reason: row.skip_reason,
    fuzzy_match_status: row.fuzzy_match_status,
    fuzzy_match_score: row.fuzzy_match_score,
    created_at: row.created_at,
    last_updated: row.last_updated,
  };
}
