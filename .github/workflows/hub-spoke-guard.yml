name: Hub & Spoke Architecture Guard

on:
  pull_request:
    branches: ['main']
  push:
    branches: ['main']

jobs:
  architecture-guard:
    runs-on: ubuntu-latest
    name: Architecture Enforcement

    steps:
      - name: Checkout code
        uses: actions/checkout@v3

      - name: Setup Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.11'

      - name: Install dependencies
        run: |
          pip install pyyaml

      # ========================================================================
      # CHECK 1: Repo Shape Guard (same rules as pre-commit hook)
      # ========================================================================
      - name: Repo Shape Guard
        run: |
          echo "üîí Running Repo Shape Guard..."

          # Allowed top-level directories
          ALLOWED_DIRS=".github .vscode .claude .devcontainer contracts docs doctrine hubs migrations ops shared spokes templates tests src"

          # Check for Python files at root
          ROOT_PY=$(find . -maxdepth 1 -name "*.py" -type f | head -5)
          if [ -n "$ROOT_PY" ]; then
            echo "‚ùå BLOCKED: Python files found at repo root"
            echo "$ROOT_PY"
            exit 1
          fi
          echo "‚úì No Python files at repo root"

          # Check for unauthorized top-level directories
          for dir in $(find . -maxdepth 1 -type d -not -name "." -not -name ".git"); do
            dirname=$(basename "$dir")
            if ! echo "$ALLOWED_DIRS" | grep -qw "$dirname"; then
              echo "‚ùå BLOCKED: Unauthorized directory: $dirname/"
              echo "Allowed: $ALLOWED_DIRS"
              exit 1
            fi
          done
          echo "‚úì All directories are in allowlist"

          echo "‚úÖ Repo Shape Guard passed"

      # ========================================================================
      # CHECK 2: Hub Manifests Validation
      # ========================================================================
      - name: Validate Hub Manifests
        run: |
          echo "üìã Validating Hub Manifests..."

          REQUIRED_HUBS="company-target people-intelligence dol-filings outreach-execution"

          for hub in $REQUIRED_HUBS; do
            MANIFEST="hubs/${hub}/hub.manifest.yaml"

            if [ ! -f "$MANIFEST" ]; then
              echo "‚ùå MISSING: $MANIFEST"
              exit 1
            fi

            # Validate YAML syntax
            python3 -c "import yaml; yaml.safe_load(open('$MANIFEST'))" 2>/dev/null || {
              echo "‚ùå INVALID YAML: $MANIFEST"
              exit 1
            }

            # Verify required fields exist
            python3 << EOF
import yaml
import sys

with open("$MANIFEST") as f:
    manifest = yaml.safe_load(f)

required_fields = ["hub_id", "doctrine_id", "core_metric", "entities_owned"]
missing = [f for f in required_fields if f not in manifest]

if missing:
    print(f"‚ùå MISSING FIELDS in $MANIFEST: {missing}")
    sys.exit(1)

# Verify IMO structure is defined
if "imo_structure" not in manifest:
    print(f"‚ùå MISSING imo_structure in $MANIFEST")
    sys.exit(1)

print(f"‚úì {manifest['hub_id']}: Valid manifest with {manifest['core_metric']} metric")
EOF

          done

          echo "‚úÖ All hub manifests validated"

      # ========================================================================
      # CHECK 3: Spoke Contracts Validation
      # ========================================================================
      - name: Validate Spoke Contracts
        run: |
          echo "üìÑ Validating Spoke Contracts..."

          CONTRACTS=$(find contracts -name "*.contract.yaml" 2>/dev/null || true)

          if [ -z "$CONTRACTS" ]; then
            echo "‚ö†Ô∏è No spoke contracts found in contracts/"
            exit 0
          fi

          for contract in $CONTRACTS; do
            echo "Checking: $contract"

            # Validate YAML syntax
            python3 -c "import yaml; yaml.safe_load(open('$contract'))" 2>/dev/null || {
              echo "‚ùå INVALID YAML: $contract"
              exit 1
            }

            # Verify required fields
            python3 << EOF
import yaml
import sys

with open("$contract") as f:
    contract_data = yaml.safe_load(f)

required_fields = ["contract_id", "source_hub", "target_hub", "direction"]
missing = [f for f in required_fields if f not in contract_data]

if missing:
    print(f"‚ùå MISSING FIELDS in $contract: {missing}")
    sys.exit(1)

# Verify direction is valid
valid_directions = ["ingress", "egress", "bidirectional"]
if contract_data.get("direction") not in valid_directions:
    print(f"‚ùå INVALID direction in $contract: must be one of {valid_directions}")
    sys.exit(1)

print(f"‚úì {contract_data['contract_id']}: {contract_data['source_hub']} ‚Üî {contract_data['target_hub']}")
EOF

          done

          echo "‚úÖ All spoke contracts validated"

      # ========================================================================
      # CHECK 4: Spoke Purity Linter
      # ========================================================================
      - name: Run Spoke Purity Linter
        run: |
          echo "üîç Running Spoke Purity Linter..."

          # tooling/ directory was removed during repo cleanup.
          # Running inline spoke purity checks instead.
          echo "Running inline spoke purity checks..."

          python3 << 'EOF'
import os
import ast
import sys

FORBIDDEN_PATTERNS = [
    "sqlite",
    "psycopg",
    "neon",
    "requests.get",
    "requests.post",
    "httpx",
    "aiohttp",
    "redis",
    "mongo",
]

FORBIDDEN_IMPORTS = [
    "pandas",
    "numpy",
    "sqlalchemy",
    "psycopg2",
    "redis",
    "pymongo",
    "requests",
]

violations = []
spokes_dir = "spokes"

if not os.path.exists(spokes_dir):
    print("No spokes/ directory found")
    sys.exit(0)

for root, dirs, files in os.walk(spokes_dir):
    for fname in files:
        if not fname.endswith(".py"):
            continue

        fpath = os.path.join(root, fname)

        try:
            with open(fpath, "r") as f:
                content = f.read()
                tree = ast.parse(content)
        except:
            continue

        # Check for forbidden imports
        for node in ast.walk(tree):
            if isinstance(node, ast.Import):
                for alias in node.names:
                    if alias.name.split(".")[0] in FORBIDDEN_IMPORTS:
                        violations.append(f"{fpath}: Forbidden import '{alias.name}'")

            elif isinstance(node, ast.ImportFrom):
                if node.module and node.module.split(".")[0] in FORBIDDEN_IMPORTS:
                    violations.append(f"{fpath}: Forbidden import from '{node.module}'")

        # Check for forbidden patterns in source
        for pattern in FORBIDDEN_PATTERNS:
            if pattern in content:
                violations.append(f"{fpath}: Contains forbidden pattern '{pattern}'")

if violations:
    print("‚ùå SPOKE PURITY VIOLATIONS:")
    for v in violations:
        print(f"  - {v}")
    sys.exit(1)

print("‚úì All spokes pass purity checks")
EOF

          echo "‚úÖ Spoke Purity Linter passed"

      # ========================================================================
      # CHECK 5: Identity Minting Guard (P0-7)
      # Outreach hubs cannot mint company_unique_id - CL only
      # ========================================================================
      - name: Identity Minting Guard
        run: |
          echo "üîê Checking for forbidden identity minting patterns..."

          python3 << 'EOF'
import os
import re
import sys

# Forbidden identity minting patterns
# Outreach is a CONSUMER of CL identity, not a creator
FORBIDDEN_PATTERNS = [
    # Direct UUID assignment to identity fields
    r"company_unique_id\s*=\s*.*uuid",
    r"company_unique_id\s*=\s*str\(uuid",
    r"company_sov_id\s*=\s*.*uuid",
    r"company_sov_id\s*=\s*str\(uuid",
    
    # Generate/mint identity functions
    r"def\s+mint_company",
    r"def\s+generate_company_id",
    r"def\s+create_company_identity",
    
    # INSERT without CL reference check
    r"INSERT\s+INTO\s+cl\.company_identity",
]

# Directories to check (Outreach hub code)
CHECK_DIRS = ["hubs", "spokes", "shared", "ops"]

violations = []

for check_dir in CHECK_DIRS:
    if not os.path.exists(check_dir):
        continue
    
    for root, dirs, files in os.walk(check_dir):
        # Skip test directories
        if "test" in root.lower():
            continue
            
        for fname in files:
            if not fname.endswith(".py"):
                continue
            
            fpath = os.path.join(root, fname)
            
            with open(fpath, "r", encoding="utf-8", errors="ignore") as f:
                content = f.read()
            
            for pattern in FORBIDDEN_PATTERNS:
                matches = re.findall(pattern, content, re.IGNORECASE)
                if matches:
                    violations.append(
                        f"{fpath}: Identity minting pattern detected - '{pattern}'"
                    )

if violations:
    print("‚ùå IDENTITY MINTING VIOLATIONS:")
    print("")
    print("DOCTRINE: Outreach is a CONSUMER of CL identity, not a creator.")
    print("CL (Company Lifecycle) is the ONLY hub that can mint company_unique_id.")
    print("")
    for v in violations:
        print(f"  - {v}")
    print("")
    print("Fix: Remove identity minting logic. Request identity from CL instead.")
    sys.exit(1)

print("‚úì No identity minting patterns detected")
EOF

          echo "‚úÖ Identity Minting Guard passed"

      # ========================================================================
      # CHECK 6: Fuzzy Matching Guard (P0-8)
      # Outreach hubs cannot use fuzzy matching for identity resolution
      # ========================================================================
      - name: Fuzzy Matching Guard
        run: |
          echo "üîç Checking for forbidden fuzzy matching patterns..."

          python3 << 'EOF'
import os
import re
import sys

# Forbidden fuzzy matching imports and patterns
FORBIDDEN_IMPORTS = [
    r"from\s+rapidfuzz",
    r"import\s+rapidfuzz",
    r"from\s+fuzzywuzzy",
    r"import\s+fuzzywuzzy", 
    r"from\s+thefuzz",
    r"import\s+thefuzz",
]

FORBIDDEN_PATTERNS = [
    r"fuzzy_match",
    r"fuzzy_score",
    r"fuzz\.ratio",
    r"fuzz\.partial_ratio",
    r"process\.extract",
    r"process\.extractOne",
]

# Directories to check
CHECK_DIRS = ["hubs", "spokes", "shared"]

violations = []

for check_dir in CHECK_DIRS:
    if not os.path.exists(check_dir):
        continue
    
    for root, dirs, files in os.walk(check_dir):
        # Skip archive directories
        if "archive" in root.lower():
            continue
            
        for fname in files:
            if not fname.endswith(".py"):
                continue
            
            fpath = os.path.join(root, fname)
            
            with open(fpath, "r", encoding="utf-8", errors="ignore") as f:
                content = f.read()
            
            # Check imports
            for pattern in FORBIDDEN_IMPORTS:
                if re.search(pattern, content):
                    violations.append(f"{fpath}: Fuzzy library import - '{pattern}'")
            
            # Check patterns (exclude comments)
            lines = content.split('\n')
            for i, line in enumerate(lines):
                # Skip comments
                if line.strip().startswith('#'):
                    continue
                for pattern in FORBIDDEN_PATTERNS:
                    if re.search(pattern, line):
                        violations.append(
                            f"{fpath}:{i+1}: Fuzzy pattern - '{pattern}'"
                        )

if violations:
    print("‚ùå FUZZY MATCHING VIOLATIONS:")
    print("")
    print("DOCTRINE: Outreach cannot use fuzzy matching for identity resolution.")
    print("Identity matching is CL's responsibility. Outreach consumes verified identity.")
    print("")
    for v in violations:
        print(f"  - {v}")
    print("")
    print("Fix: Remove fuzzy matching. Use exact match or request CL verification.")
    sys.exit(1)

print("‚úì No fuzzy matching patterns detected")
EOF

          echo "‚úÖ Fuzzy Matching Guard passed"

      # ========================================================================
      # CHECK 5: Hub IMO Structure Verification
      # ========================================================================
      - name: Verify Hub IMO Structure
        run: |
          echo "üìÅ Verifying Hub IMO Structure..."

          REQUIRED_HUBS="company-target people-intelligence dol-filings outreach-execution"
          IMO_DIRS="input middle output"

          for hub in $REQUIRED_HUBS; do
            HUB_DIR="hubs/${hub}/imo"

            if [ ! -d "$HUB_DIR" ]; then
              echo "‚ùå MISSING: $HUB_DIR/"
              exit 1
            fi

            for imo in $IMO_DIRS; do
              if [ ! -d "$HUB_DIR/$imo" ]; then
                echo "‚ùå MISSING: $HUB_DIR/$imo/"
                exit 1
              fi
            done

            echo "‚úì hubs/${hub}/imo/{input,middle,output}/ exists"
          done

          echo "‚úÖ All hubs have proper IMO structure"

      # ========================================================================
      # CHECK 6: No Sideways Hub-to-Hub Imports
      # ========================================================================
      - name: Check Hub Isolation
        run: |
          echo "üîó Checking Hub Isolation (no sideways imports)..."

          python3 << 'EOF'
import os
import re
import sys

violations = []
hubs_dir = "hubs"

if not os.path.exists(hubs_dir):
    print("No hubs/ directory found")
    sys.exit(0)

# Map of hub directories
hub_dirs = [d for d in os.listdir(hubs_dir) if os.path.isdir(os.path.join(hubs_dir, d))]

for hub in hub_dirs:
    hub_path = os.path.join(hubs_dir, hub)

    for root, dirs, files in os.walk(hub_path):
        for fname in files:
            if not fname.endswith(".py"):
                continue

            fpath = os.path.join(root, fname)

            with open(fpath, "r") as f:
                content = f.read()

            # Check for imports from other hubs
            for other_hub in hub_dirs:
                if other_hub == hub:
                    continue

                # Check for direct hub imports
                patterns = [
                    rf"from\s+hubs\.{other_hub}",
                    rf"import\s+hubs\.{other_hub}",
                    rf"from\s+\.\.{other_hub}",
                ]

                for pattern in patterns:
                    if re.search(pattern, content):
                        violations.append(
                            f"{fpath}: Illegal sideways import from '{other_hub}' hub"
                        )

if violations:
    print("‚ùå HUB ISOLATION VIOLATIONS:")
    print("   Hubs must communicate through spokes, not direct imports!")
    for v in violations:
        print(f"  - {v}")
    sys.exit(1)

print("‚úì No sideways hub-to-hub imports detected")
EOF

          echo "‚úÖ Hub Isolation check passed"

      # ========================================================================
      # CHECK 7: Phantom Import Guard (DV-030)
      # Blocks hub.company.*, ctb.*, backend.* - paths that don't exist
      # ========================================================================
      - name: Phantom Import Guard
        run: |
          echo "üëª Checking for phantom import patterns..."

          python3 << 'EOF'
import os
import re
import sys

# Phantom import patterns - paths that DO NOT EXIST in this repo
# These were copied from non-existent ctb.* architecture
PHANTOM_PATTERNS = [
    # hub.company.* (singular 'hub' - wrong path, should be hubs.company_target)
    r"^from\s+hub\.company",
    r"^import\s+hub\.company",
    r"^from\s+hub\.",
    r"^import\s+hub\.",

    # ctb.* (phantom CTB module - does not exist)
    r"^from\s+ctb\.",
    r"^import\s+ctb\.",

    # backend.* (phantom backend module - does not exist)
    r"^from\s+backend\.",
    r"^import\s+backend\.",
]

# Directories to check
CHECK_DIRS = ["hubs", "spokes", "shared", "ops"]

violations = []

for check_dir in CHECK_DIRS:
    if not os.path.exists(check_dir):
        continue

    for root, dirs, files in os.walk(check_dir):
        for fname in files:
            if not fname.endswith(".py"):
                continue

            fpath = os.path.join(root, fname)

            with open(fpath, "r", encoding="utf-8", errors="ignore") as f:
                lines = f.readlines()

            for line_num, line in enumerate(lines, 1):
                # Skip comments
                stripped = line.strip()
                if stripped.startswith('#'):
                    continue

                for pattern in PHANTOM_PATTERNS:
                    if re.search(pattern, stripped):
                        violations.append(
                            f"{fpath}:{line_num}: Phantom import '{stripped[:60]}...'"
                        )

if violations:
    print("‚ùå PHANTOM IMPORT VIOLATIONS:")
    print("")
    print("These import paths DO NOT EXIST in this repository:")
    print("  - hub.company.* ‚Üí Use hubs.company_target.* instead")
    print("  - ctb.* ‚Üí CTB module does not exist, use stub placeholders")
    print("  - backend.* ‚Üí Backend module does not exist")
    print("")
    for v in violations:
        print(f"  - {v}")
    print("")
    print("Fix: Comment out phantom imports and add stub placeholders.")
    sys.exit(1)

print("‚úì No phantom imports detected")
EOF

          echo "‚úÖ Phantom Import Guard passed"

      # ========================================================================
      # SUMMARY
      # ========================================================================
      - name: Architecture Guard Summary
        if: always()
        run: |
          echo ""
          echo "‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó"
          echo "‚ïë          HUB & SPOKE ARCHITECTURE GUARD COMPLETE             ‚ïë"
          echo "‚ï†‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ï£"
          echo "‚ïë  ‚úì Repo Shape Guard                                          ‚ïë"
          echo "‚ïë  ‚úì Hub Manifests Validation                                  ‚ïë"
          echo "‚ïë  ‚úì Spoke Contracts Validation                                ‚ïë"
          echo "‚ïë  ‚úì Spoke Purity Linter                                       ‚ïë"
          echo "‚ïë  ‚úì Identity Minting Guard (CL-only enforcement)              ‚ïë"
          echo "‚ïë  ‚úì Fuzzy Matching Guard (no fuzzy in Outreach)               ‚ïë"
          echo "‚ïë  ‚úì Hub IMO Structure Verification                            ‚ïë"
          echo "‚ïë  ‚úì Hub Isolation Check                                       ‚ïë"
          echo "‚ïë  ‚úì Phantom Import Guard (hub.*, ctb.*, backend.*)            ‚ïë"
          echo "‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù"
          echo ""
          echo "All architecture enforcement checks completed."
